# Life Management

## Task Management

### [Getting Things Done](orgmode.md)

* New: [Capture all your stuff.](gtd.md#capture-all-your-stuff)

    The focus of this process is to capture *everything* that has your attention, otherwise some part of you will still not totally trust that you're working with the whole picture. While you're doing it, create a list of all the sources of inputs in your world.
    
    What you're going to do is methodically go through each piece of your life and search for anything that doesn’t permanently belong where it is, the way it is, and put it into your in-tray. You’ll be gathering things that are incomplete or things that have some decision about potential action tied to them. They all go into your “inbox”, so they’ll be available for later processing.
    
    Be patient, this process may take between 1 and 6 hours, and at the end you'll have a huge pile of stuff in your inbox. You might be scared and get the thought of "what am I doing with my life?", but don't worry you'll get everything in order soon :).
    
    The steps described in the section so far are:
    
    * [Define what is going to be your in-tray](gtd.md#define-what-is-going-to-be-your-in-tray)
    * [Physical gathering](gtd.md#physical-gathering)

* New: [Digital general reference.](gtd.md#digital-general-reference)

    It is very helpful to have a visual map sorted in ways that make sense, either by indexes or data groups organized effectively, usually in an alphabetic order.
    
    The biggest issue for digitally oriented people is that the ease of capturing and storing has generated a write-only syndrome: all they’re doing is capturing information—not actually accessing and using it intelligently. Some consciousness needs to be applied to keep one’s potentially huge digital library functional, versus a black hole of data easily dumped in there with a couple of keystrokes.
    
    You need to consistently check how much room to give yourself so that the content remains meaningfully and easily accessible, without creating a black hole of an inordinate amount of information amorphously organized.

* New: [Physical general reference.](gtd.md#physical-general-reference)

    One idea is to have one system/place where you order the content alphabetically, not multiple ones. People have a tendency to want to use their files as a personal management system, and therefore they attempt to organize them in groupings by projects or areas of focus. This magnifies geometrically the number of places something isn’t when you forget where you filed it.

* New: [Use telescope plugin for refiling.](orgmode.md#refiling)

    Refiling lets you easily move around elements of your org file, such as headings or TODOs. You can refile with `<leader>r` with the next snippet:
    
    ```lua
    org = {
      org_refile = '<leader>r',
    }
    ```
    
    When you press the refile key binding you are supposed to press `<tab>` to see the available options, once you select the correct file, if you will be shown a autocomplete with the possible items to refile it to. Luckily there is [a Telescope plugin](https://github.com/joaomsa/telescope-orgmode.nvim).
    
    Install it by adding to your plugin config:
    
    ```lua
    use 'joaomsa/telescope-orgmode.nvim'
    ```
    
    Then install it with `:PackerInstall`.
    
    You can setup the extension by doing:
    
    ```lua
    require('telescope').load_extension('orgmode')
    ```
    
    To replace the default refile prompt:
    
    ```lua
    vim.api.nvim_create_autocmd('FileType', {
      pattern = 'org',
      group = vim.api.nvim_create_augroup('orgmode_telescope_nvim', { clear = true })
      callback = function()
        vim.keymap.set('n', '<leader>r', require('telescope').extensions.orgmode.refile_heading)
        vim.keymap.set('n', '<leader>g', require('telescope').extensions.orgmode.search_headings)
      end,
    })
    ```
    
    If the auto command doesn't override the default `orgmode` one, bind it to another keys and never use it.
    
    The plugin also allows you to use `telescope` to search through the headings of the different files with `search_headings`, with the configuration above you'd use `<leader>g`.

* New: [Define the Todo list.](gtd.md#todo-list)

    This list contains all the next actions and projects you are going to actively work on. Projects are any desired result that can be accomplished within a year that requires more than one action step. This means that some rather small things you might not normally call projects are going to be on your Projects list, as well as some big ones. If one step won’t complete something, some kind of goalpost needs to be set up to remind you that there’s something still left to do. If you don’t have a placeholder to remind you about it, it will slip back into your head. The reason for the one-year time frame is that anything you are committed to finish within that scope needs to be reviewed weekly to feel comfortable about its status. Another way to think of this is as a list of open loops, no matter what the size. This is going to be one of the lists that you'll review more often, and it needs to be manageable, if the items start to grow you may want to track the elements you want to do in the semester, or trimester.
    
    Projects do not initially need to be listed in any particular order, by size, or by priority. They just need to be on a master list so you can review them regularly enough to ensure that appropriate next actions have been defined for each of them. That being said, I like to order them a little bit so that I don't need to read the whole list to choose what to do.
    
    There may be reasons to sort your projects into different subcategories, based upon different areas of your focus, but initially creating a single list of all of them will make it easier to customize your system appropriately as you get more comfortable with its usage. To sort them use tags instead of hierarchical structures, they are more flexible. For example you could use tags for:
    
    - Context: Where can you do the element: `home`, `computer`, `mobile`, ...
    - Area: Broad categories where the element falls in: `activism`, `caring`, `self-caring`, `home`, `digital services`, ...
    - Type: I like to separate the tasks that are meant to survive (`maintenance`) from the ones that are meant to improve things (`improvement`)
    - Mood, energy level, time: It's useful to have a quick way to see the tasks you can work on when you don't have that much time (`small`), you don't have that much mental energy (`brainless`), when you're `sad`, ...
    
    For many of your projects, you will accumulate relevant information that you will want to organize by theme or topic or project name. Your Projects list will be merely an index. All of the details, plans, and supporting information that you may need as you work on your various projects should be contained in your References system.

* New: [Define the calendar.](gtd.md#calendar)

    The calendar holds reminders of actions you need to take fall into two categories: those about things that have to happen on a specific day or time, and those about things that just need to get done as soon as possible. Your calendar handles the first type of reminder.
    
    These things go on your calendar:
    
    * Time-Specific actions or appointments.
    * Day-Specific actions: These are things that you need to do sometime on a certain day, but not necessarily at a specific time.
    * Day-Specific information: Information that may be useful on a certain date. This might include directions for appointments, activities that other people will be involved in then, or events of interest. It’s helpful to put short-term tickler information here, too, such as a reminder to call someone after he or she returns from vacation. This is also where you would want to park important reminders about when something might be due, or when something needs to be started, given a determined lead time.
    
    Daily to-do lists don't belong to the calendar because:
    
    * Constant new input and shifting tactical priorities reconfigure daily work so consistently that it’s virtually impossible to nail down to-do items ahead of time. Having a working game plan as a reference point is always useful, but it must be able to be renegotiated at any moment. Trying to keep a list on the calendar, which must then be reentered on another day if items don’t get done, is demoralizing and a waste of time. The Next Actions lists will hold all of those action reminders, even the most time-sensitive ones. And they won’t have to be rewritten daily.
    
    * If there’s something on a daily to-do list that doesn’t absolutely have to get done that day, it will dilute the emphasis on the things that truly do. The calendar should be sacred territory. If you write something there, it must get done that day or not at all.
    
    That said, there’s absolutely nothing wrong with creating a quick, informal, short list of “if I have time, I’d really like to . . .” kinds of things, picked from your Next Actions inventory. It just should not be confused with your “have-tos,” and it should be treated lightly enough to discard or change quickly as the inevitable surprises of the day unfold.

* New: [Give an overview of how I'm using gtd.](gtd.md#design-your-system)

    Before you start moving stuff around it's a good idea to get the first design of your whole system, in my case I'm going to heavily rely on org-mode to track most of the stuff with a repository with the next structure:
    
    ```
    .
    ├── calendar
    │   ├── personal.org
    │   │   ├── One time events
    │   │   ├── Recurring events
    │   │   ├── Birthdays
    │   │   └── Deathdays
    │   ├── day.org
    │   ├── tickler.org
    │   ├── work_1.org
    │   ├── work_2.org
    │   ├── partner.org
    │   ├── family.org
    ├── inbox
    │   ├── computer.org
    │   ├── mobile.org
    │   └── tablet.org
    ├── reference
    │   ├── blue
    │   ├── reference.org
    │   └── red
    └── todo
        ├── personal.org
        ├── work_1.org
        ├── work_2.org
        └── someday.org
    ```
    
    Where:
    
    * The subtrees behind the `.org` files are the heading trees.
    * All `org` files go with their respective `org_archive` ones, they're not shown in the above diagram to keep it simple.
    * `calendar/personal.org` is my [personal calendar](gtd.md#personal-calendar).
    * `calendar/day.org` is my [day planner](gtd.md#day-planner).

* New: [Define how to use the Personal calendar.](gtd.md#personal-calendar)

    The `calendar/personal.org` file holds:
    
    - [Appointments](orgmode.md#appointments): Meant to be used for elements of the org file that have a defined date to occur. You whether do it that date or not do it at all. Avoid using dates to organize your tasks and if you don't do it that day, reschedule it to another date, it's a waste of time, use next actions in your `todo` instead. If you need to act on it use a `TODO` element, otherwise a headline is enough An example would be.
    
      ```org
      * TODO Meet with Marie
      <2023-02-24 Fri>
    
      * Internet's birthday
      <2023-03-13 Mon>
      ```
    
    - [Recurring events](orgmode.md#recurring-tasks): Events that not only happen on the given date, but again and again after a certain interval of N hours (h), days (d), weeks (w), months (m), or years (y). The following shows up in the agenda every Wednesday:
    
      ```org
      * TODO Go to pilates
        <2007-05-16 Wed 12:30 +1w>
      ```
    
    - [Tickler events](#tickler-management): Check the [Tickler management](#tickler-management) section for more details.
    
    Each section has it's own tag: `:recurring:`, `:day:`, `:birthday:`, `:deathday:`, and the whole file has the `:event:` tag for easy filtering.
    
    In rare cases you may want to use the [`DEADLINE`](orgmode.md#deadline) property if you want to be warned in the agenda some days before the date arrives or the [`SCHEDULED`](orgmode.md#scheduled) one in case you want to see in the agenda when you start working on the task. Again, don't waste time postponing these dates, if you do, you're using the system wrong.

* New: [Define how to use the Day planner.](gtd.md#day-planner)

    Some of my day events are semi-regular, meaning that the recurrence options are not powerful enough. For example, I usually go to pilates on Tuesdays, but some weeks I go at 18:00 and others at 19:00. In the past I used a script that interacts with [`ikhal`](khal.md) to create the elements of the day based on some questionary. The idea is to migrate the tool to create appointments in the day under the `diary.org` file using a `datetree` structure:
    
    ```org
    * 2010
    ** 2010-12 December
    *** 2010-12-20 Tuesday
    **** TODO Go to pilates
        <2010-12-20 Tue 19:00-20:00>
    ```
    
    I also use this file to add any diary annotations for my [life log](life_logging.md). Once [this issue is solved](https://github.com/nvim-orgmode/orgmode/issues/516) it will be really easy to add diary thoughts through the [capture feature](orgmode.md#capture)

* New: [Define how to use the todo files.](gtd.md#todo-files)

    The `todo` files are where you track the [todo list](gtd.md#todo-list), which holds your projects and their next steps to work on. The `todo/personal.org`, `todo/work_1.org` and `todo/work_2.org` files of [the above schema](#design-your-system) will be divided into these level 1 headings:
    
    - `* Necessary`: These projects need to be dealt with immediately and finished as soon as possible
    - `* Desirable`: Here is where most of your elements will be, these are the ones that you think it's important to work on but there is no hard pressure.
    - `* Optional`: These are the projects that it would be nice to work on, but if you don't it's fine.
    
    Projects are any the second level headings with TODO keywords. To see the list of your projects just fold all the items in the `todo.org` file.
    
    Inside each section the elements are more less ordered by what I want to work on first. But all projects are actionable, so if I'm not in the mood to do the first ones, I tackle the rest. As such, I try not to spend too much time ordering them.
    
    I find useful to split the tasks between my life silos, so that I don't even have a chance to think of anything of `work_1` when I'm doing my `personal` stuff or `work_2` stuff.

* New: [Define how to work with projects.](gtd.md#project-structure)

    Given the broad definition of what we consider a project and how they are usually cooked, the system that represents it must be equally flexible, quick to interact with and easy to evolve.
    
    Every project starts with the title:
    
    ```org
    * TODO Improve task management system
    ```
    
    Optionally you can add a description
    
    ```org
    * TODO Improve task management system
      Using Openprojects is uncomfortable, I need to find a better system.
    ```
    
    You may have noticed that the description doesn't follow the rules we defined for next actions, that's fine as you don't act on projects, but on their underlying actions. Nevertheless I like to start them with a verb. It may even make sense not to use TODO items but simple headings to define your projects. On one side you don't act on projects so it would make sense to use headings, on the other, it's also interesting to know the project state, which can be easily tracked with the TODO keywords. If you could tell apart headings from TODO items in the [agenda](orgmode.md#agenda) views it would make sense to use them. Right now `nvim-orgmode` let's you select in the agenda views only TODO items or TODO and headings, but you can't select only headings, so at the moment I don't see any good reason not to use TODO items for the projects.
    
    To define the next actions of a project you can use checklists
    
    ```org
    * TODO Improve task management system
      - [-] Read David Allen's GTD book
        - [x] Read chapters 6 and 7
        - [ ] Read chapters 8 and 9
      - [ ] Sum up the book in the blue book
    ```
    
    As your checklists grow they may start to be uncomfortable, for example if it has:
    
    - More than two levels of indentation: It may be hard to follow the logic of the task structure.
    - A lot of elements: You can't archive parts of checklists, so as you complete elements, they will still be shown diverting your attention from the things you can actually act upon or making you loose time scrolling to find where they are.
    
    In these cases it makes sense to promote the first level of headings to subprojects:
    
    ```org
    * TODO Improve task management system
      * DOING Read David Allen's GTD book
        - [x] Read chapters 6 and 7
        - [ ] Read chapters 8 and 9
      * TODO up the book in the blue book
    ```
    
    That way when `Read David Allen's GTD book` is done, you can archive it and forget about it.
    
    If the project starts having many subprojects, it may help to have a section "Outcomes" to define what do you want to achieve with the project. It can be accompanied with a "Next Steps" section to add any subproject or action that doesn't match the defined outcomes, and once you finish the project, you can refile them into new projects.

* New: [The NEXT state.](gtd.md#the-next-state)

    It's useful to have a `NEXT` state to track the first next action you need to deal with for each project. That way when you open the file, you can go to the top of it and search for `NEXT` and it will lead you directly to where you need to work on.

* New: [Define how to manage tags.](gtd.md#tag-management)

    As explained in the [todo list](gtd.md#todo-list) section, you can use tags to filter your tasks. I'm using the next ones:
    
    - Area: Broad categories where the element falls in: `activism`, `caring`, `self-caring`, `home`, `digital services`, ...
    - Type: I like to separate the tasks that are meant to survive (`maintenance`) from the ones that are meant to improve things (`improvement`). I use these only in the big projects.
    - `:long_break:`: I'm using this tag to track the small projects that can be done in the [long pomodoro breaks](task_workflows.md). Depending on the kind of long break that I need I then filter for the next tags:
      - `brainless`: If I want to keep on thinking on what I was doing, an example could be emptying the dishwasher, watering the plants, ...
      - `call`: If I want to completely change context and want some social interaction. For example call mom.

* New: [Define how to manage waiting tasks.](gtd.md#waiting-tasks)

    Waiting actions are elements that are blocked for any reason. I use the `WAITING` TODO keyword to track this state. Under each element you should add that reason and optionally the process you want to follow to unblock it.
    
    If you need to actively track the evolution of the WAITING status, leave it on the top of your `todo`. Otherwise set the date you want to check its status and move it to the `ticker.org` file.

* New: [Define how to use the tickler.](gtd.md#tickler-management)

    The tickler is a system where you postpone actions to a specific date, but not with a calendar mindset where the action **needs** to be done at that date. With the tickler you schedule the action to enter your inbox that day to decide what are you going to do with it.
    
    To implement this in orgmode you can add the `:tickler:` tag to any element that is tracked in the agenda files and once a day you can look at the day's agenda and decide what to do with the action. It's important though that whatever you do with it, you have to remove it from the agenda view in order to only keep the elements that you need to do in the day. You can follow this workflow by:
    
    - Opening the agenda view `gaa`
    - Go to the view of the day `vd`
    - Go to today `.`
    - Search by tickler `/tickler`
    
    It can also help to review in the weeklies all the ticklers of the week to avoid surprises.
    
    If you want to make the project go away from your `todo` or `someday` until the tickler date, move it to the `tickler.org` file.

* Correction: [Keep on defining steps to capture all your stuff.](gtd.md#capture-all-your-stuff)

    As you engage in the capturing step, you may run into one or more of the following problems:
    
    * An item is too big to go in the in-tray: create a post it that represents it or add it as an entry in your digital inbox. If you can, add the date too
    * The pile is too big to fit the in-tray: Create visually distinct stacks around the in-tray, even on the floor.
    * Doubts whether to trash something: When in doubt keep it, you'll decide about it later when you process the in-tray. What you need to avoid is to get caught up in deciding what to do with the element. That's going to be the next step in the process, let's go one at a time.
    * Getting caught up in cleaning and organizing: If it doesn't take that long it's fine but remember the purpose of this process and the fact that we want to finish it as soon as possible. If you discover things you want to change, add them to the in-tray.
    * If you encounter stuff that is already on lists and organizers, treat them as everything else in the "in".
    
    Now that the process it's clear let's start.
    
    Start with the space where you actually do stuff, scan the place centimeter by centimeter with the mindset defined above, check your desk, drawers, floors, walls, shelves, equipment, furniture, fixtures...Then repeat the process with each room of your home.

* New: [Explain how to capture all your mental stuff.](gtd.md#mental-gathering)

    Once you already have a nice pile of stuff, think of what has your attention that isn’t represented by something already in your in-tray and record each thought, each idea, each project or thing that occurs you and add it to the inbox.
    
    To assist in clearing your head, you may want to review the [following the next trigger list](gtd.md#mental-gathering), item by item, to see if you’ve forgotten anything.

* New: Define priorities from A to D.

    I feel more comfortable with these priorities:
    
    - `A`: Critical
    - `B`: High
    - `C`: Normal
    - `D`: Low
    
    This gives you room to usually work on priorities `B-D` and if something shows up that is really really important, you can use `A`. You can set this setting with the next snippet:
    
    ```lua
    require('orgmode').setup({
      org_priority_highest = 'A',
      org_priority_default = 'C',
      org_priority_lowest = 'D',
    })
    ```

* New: Warn against using DEADLINE.

    Using too many tasks with a `DEADLINE` will clutter your agenda. Use it only for the actions that you need to have a reminder, instead try to using [appointment](#appointments) dates instead.
    
    If you need a different warning period for a special task, you can specify it. For example setting a warning period of 5 days `DEADLINE: <2004-02-29 Sun -5d>`. To configure the default number of days add:
    
    ```lua
    require('orgmode').setup({
      org_deadline_warning_days = 10,
    })
    ```

* Correction: [Improve how to use tags.](orgmode.md#tags)

    When you press the tag key binding you can type:
    
    * `tag1`: It will add `:tag1:`.
    * `tag1:tag2`: It will add `:tag1:tag2:`.
    * Press `ESC`: It will remove all tags from the item.
    
    Tags make use of the hierarchical structure of outline trees. If a heading has a certain tag, all subheadings inherit the tag as well. For example, in the list
    
    ```
    * Meeting with the French group      :work:
    ** Summary by Frank                  :boss:notes:
    *** TODO Prepare slides for him      :action:
    ```
    
    The final heading has the tags `work`, `boss`, `notes`, and `action` even though the final heading is not explicitly marked with those tags. You can also set tags that all entries in a file should inherit just as if these tags were defined in a hypothetical level zero that surrounds the entire file. Using a line like the next one:
    
    ```
     #+FILETAGS: :Peter:Boss:Secret:
    ```

* New: [How to use links.](orgmode.md#links)

    One final aspect of the org file syntax are links. Links are of the form `[[link][description]]`, where link can be an:
    
    * [Internal reference](orgmode.md#internal-document-links)
    * [External reference](orgmode.md#external-links)
    
    A link that does not look like a URL refers to the current document. You can follow it with `gx` when point is on the link (Default `<leader>oo`) if you use the next configuration.
    
    ```lua
    org = {
      org_open_at_point = 'gx',
    }
    ```

* New: [Internal document links.](orgmode.md#internal-document-links)

    Org provides several refinements to internal navigation within a document. Most notably:
    
    * `[[*Some section]]`: points to a headline with the name `Some section`.
    * `[[#my-custom-id]]`: targets the entry with the `CUSTOM_ID` property set to `my-custom-id`.
    
    When the link does not belong to any of the cases above, Org looks for a dedicated target: the same string in double angular brackets, like `<<My Target>>`.
    
    If no dedicated target exists, the link tries to match the exact name of an element within the buffer. Naming is done, unsurprisingly, with the `NAME` keyword, which has to be put in the line before the element it refers to, as in the following example
    
    ```org
     #+NAME: My Target
    | a  | table      |
    |----+------------|
    | of | four cells |
    ```
    
    Ultimately, if none of the above succeeds, Org searches for a headline that is exactly the link text but may also include a `TODO` keyword and tags, or initiates a plain text search.
    
    Note that you must make sure custom IDs, dedicated targets, and names are unique throughout the document. Org provides a linter to assist you in the process, if needed, but I have not searched yet one for nvim.

* New: [How to use properties.](orgmode.md#properties)

    Properties are key-value pairs associated with an entry. They live in a special drawer with the name `PROPERTIES`. Each property is specified on a single line, with the key (surrounded by colons) first, and the value after it:
    
    ```org
    * CD collection
    ** Classic
    *** Goldberg Variations
        :PROPERTIES:
        :Title:     Goldberg Variations
        :Composer:  J.S. Bach
        :Publisher: Deutsche Grammophon
        :NDisks:    1
        :END:
    ```
    
    You may define the allowed values for a particular property `Xyz` by setting a property `Xyz_ALL`. This special property is inherited, so if you set it in a level 1 entry, it applies to the entire tree. When allowed values are defined, setting the corresponding property becomes easier and is less prone to typing errors. For the example with the CD collection, we can pre-define publishers and the number of disks in a box like this:
    
    ```org
    * CD collection
      :PROPERTIES:
      :NDisks_ALL:  1 2 3 4
      :Publisher_ALL: "Deutsche Grammophon" Philips EMI
      :END:
    ```
    
    If you want to set properties that can be inherited by any entry in a file, use a line like:
    
    ```org
     #+PROPERTY: NDisks_ALL 1 2 3 4
    ```
    
    This can be interesting for example if you want to track when was a header created:
    
    ```org
    *** Title of header
       :PROPERTIES:
       :CREATED: <2023-03-03 Fri 12:11>
       :END:
    ```

* New: [How to do Agenda searches.](orgmode.md#agenda-searches)

    When using the search agenda view you can:
    
    * Search by TODO states with `/WAITING`
    * Search by tags `+home`. The syntax for such searches follows a simple boolean logic:
    
      - `|`: or
      - `&`: and
      - `+`: include matches
      - `-`: exclude matches
    
      Here are a few examples:
    
      - `+computer&+urgent`: Returns all items tagged both `computer` and `urgent`.
      - `+computer|+urgent`: Returns all items tagged either `computer` or `urgent`.
      - `+computer&-urgent`: Returns all items tagged `computer` and not `urgent`.
    
      As you may have noticed, the syntax above can be a little verbose, so org-mode offers convenient ways of shortening it. First, `-` and `+` imply `and` if no boolean operator is stated, so example three above could be rewritten simply as:
    
      ```
      +computer-urgent
      ```
    
      Second, inclusion of matches is implied if no `+` or `-` is present, so example three could be further shortened to:
    
      ```
      computer-urgent
      ```
    
      Example number two, meanwhile, could be shortened to:
    
      ```
      computer|urgent
      ```
    
      There is no way (as yet) to express search grouping with parentheses. The `and` operators (`&`, `+`, and `-`) always bind terms together more strongly than `or` (`|`). For instance, the following search
    
      ```
      computer|work+email
      ```
    
      Results in all headlines tagged either with `computer` or both `work` and `email`. An expression such as `(computer|work)&email` is not supported at the moment. You can construct a regular expression though:
    
      ```
      +{computer\|work}+email
      ```
    
    * [Search by properties](https://orgmode.org/worg/org-tutorials/advanced-searching.html#property-searches): You can search by properties with the `PROPERTY="value"` syntax. Properties with numeric values can be queried with inequalities `PAGES>100`. To search by partial searches use a regular expression, for example if the entry had `:BIB_TITLE: Mysteries of the Amazon` you could use `BIB_TITLE={Amazon}`

* New: [How to use Capture in orgmode.](orgmode.md#capture)

    Capture lets you quickly store notes with little interruption of your work flow. It works the next way:
    
    - Open the interface with `;c` (Default `<leader>oc`) that asks you what kind of element you want to capture.
    - Select the template you want to use. By default you only have the `Task` template, that introduces a task into the same file where you're at, select it by pressing `t`.
    - Fill up the template.
    - Choose what to do with the captured content:
      - Save it to the configured file by pressing `;w` (Default `<control>c`)
      - Refile it to a file by pressing `;r` (Default `<leader>or`).
      - Abort the capture `;q` (Default `<leader>ok`).
    
    ```lua
    mappings = {
      global = {
        org_capture = ';c',
        },
      capture = {
        org_capture_finalize = ';w',
        org_capture_refile = ';r',
        org_capture_kill = ';q',
      },
    }
    ```

* New: [Configure the capture templates.](orgmode.md#configure-the-capture-templates)

    Capture lets you define different templates for the different inputs. Each template has the next elements:
    
    * Keybinding: Keys to press to activate the template
    * Description: What to show in the capture menu to describe the template
    * Template: The actual template of the capture, look below to see how to create them.
    * Target: The place where the captured element will be inserted to. For example `~/org/todo.org`. If you don't define it it will go to the file configured in `org_default_notes_file`.
    * Headline: An [optional headline](https://github.com/nvim-orgmode/orgmode/issues/196) of the Target file to insert the element.
    
    For example:
    
    ```lua
    org_capture_templates = {
      t = { description = 'Task', template = '* TODO %?\n  %u' }
    }
    ```
    
    For the template you can use the next variables:
    
    - `%?: `Default cursor position when template is opened
    - `%t`: Prints current date (Example: `<2021-06-10 Thu>`)
    - `%T`: Prints current date and time (Example: `<2021-06-10 Thu 12:30>`)
    - `%u`: Prints current date in inactive format (Example: `[2021-06-10 Thu]`)
    - `%U`: Prints current date and time in inactive format (Example: `[2021-06-10 Thu 12:30]`)
    - `%<FORMAT>`: Insert current date/time formatted according to lua date format (Example: `%<%Y-%m-%d %A>` produces `2021-07-02 Friday`)
    - `%x`: Insert content of the clipboard via the "+" register (see `:help clipboard`)
    - `%^{PROMPT|DEFAULT|COMPLETION...}`: Prompt for input, if completion is provided an `:h inputlist` will be used
    - `%(EXP)`: Runs the given lua code and inserts the result. NOTE: this will internally pass the content to the lua `load()` function. So the body inside `%()` should be the body of a function that returns a string.
    - `%f`: Prints the file of the buffer capture was called from.
    - `%F`: Like `%f` but inserts the full path.
    - `%n`: Inserts the current `$USER`
    - `%a`: File and line number from where capture was initiated (Example: `[[file:/home/user/projects/myfile.txt +2]]`)
    
    For example:
    
    ```lua
    {
      T = {
        description = 'Todo',
        template = '* TODO %?\n %u',
        target = '~/org/todo.org'
      },
     j = {
        description = 'Journal',
        template = '\n*** %<%Y-%m-%d %A>\n**** %U\n\n%?',
        target = '~/sync/org/journal.org'
      },
      -- Nested key example:
      e =  'Event',
      er = {
        description = 'recurring',
        template = '** %?\n %T',
        target = '~/org/calendar.org',
        headline = 'recurring'
      },
      eo = {
        description = 'one-time',
        template = '** %?\n %T',
        target = '~/org/calendar.org',
        headline = 'one-time'
      },
      -- Example using a lua function
      r = {
        description = "Repo URL",
        template = "* [[%x][%(return string.match('%x', '([^/]+)$'))]]%?",
        target = "~/org/repos.org",
      }
    }
    ```

* New: [Synchronize with external calendars.](orgmode.md#synchronize-with-external-calendars)

    You may want to synchronize your calendar entries with external ones shared with other people, such as nextcloud calendar or google.
    
    The orgmode docs have a tutorial to [sync with google](https://orgmode.org/worg/org-tutorials/org-google-sync.html) and suggests some orgmode packages that do that, sadly it won't work with `nvim-orgmode`. We'll need to go the "ugly way" by:
    
    * Downloading external calendar events to ics with [`vdirsyncer`](vdirsyncer.md).
    * [Importing the ics to orgmode](#importing-the-ics-to-orgmode)
    * Editing the events in orgmode
    * [Exporting from orgmode to ics](#exporting-from-orgmode-to-ics)
    * Uploading then changes to the external calendar events with [`vdirsyncer`](vdirsyncer.md).

* New: [Comparison with Markdown.](orgmode.md#comparison-with-markdown)

    What I like of Org mode over Markdown:
    
    * The whole interface to interact with the elements of the document through key bindings:
      * Move elements around.
      * Create elements
    * The TODO system is awesome
    * The Agenda system
    * How it handles checkboxes <3
    * Easy navigation between references in the document
    * Archiving feature
    * Refiling feature
    * `#` is used for comments.
    * Create internal document links is easier, you can just copy and paste the heading similar to `[[*This is the heading]]` on markdown you need to edit it to `[](#this-is-the-heading)`.
    
    What I like of markdown over Org mode:
    
    * The syntax of the headings `## Title` better than `** Title`. Although it makes sense to have `#` for comments.
    * The syntax of the links: `[reference](link)` is prettier to read and write than `[[link][reference]]`, although this can be improved if only the reference is shown by your editor (nvim-orgmode doesn't do his yet)
    

* New: Note the importance of isolated containers.

    It's critical that all of these containers be kept distinct from one another. They each represent a discrete type of agreement we make with ourselves, to be reminded of at a specific time and in a specific way, and if they lose their edges and begin to blend, much of the value of organizing will be lost. That's why capturing and clarifying what your relationship to them is primary to getting organized.

* New: [Inbox management.](gtd.md#inbox-management)

    Inbox is the container where you [capture your stuff](#capture). I've found myself capturing stuff in each of my devices: computer, mobile phone and tablet. Each of them has their own org file under the `inbox` directory. Each of these files has the `#+FILETAGS: :inbox:` heading so that all elements share the tag.
    
    Part of the daily planning is to check the computer and mobile inboxes to see if there is anything that needs to be processed on the day. I don't check the tablet inbox as there's usually no urgent stuff there. The rest of the elements will be processed on the weekly review leaving all the inbox files empty.

* New: [Computer inbox management.](gtd.md#computer-inbox-management)

    [`nvim-orgmode`](orgmode.md) has an awesome feature called [capture](orgmode.md#capture) which lets you capture thoughts with a keystroke. This is awesome as no matter what are you doing inside `neovim` you can quickly record your thought, action or idea and keep on doing whatever you were doing. It's a very efficient way to record your *stuff* at the same time as you keep your focus.
    
    You can use the next capture template:
    
    ```lua
      org_capture_templates = {
        i = {
          description = "Inbox",
          template = "* TODO %?\n %U",
          target = "~/org/inbox/computer.org",
        },
      }
    ```

* New: [Mobile and tablet inbox management.](gtd.md#mobile-and-tablet-inbox-management)

    To capture the content on the go you can use the [orgzly](orgzly.md) and then sync them with your computer through [syncthing](syncthing.md).

* New: [Calendar management.](gtd.md#calendar-management)

    You need to trust your calendar as sacred territory, reflecting the exact hard edges of your day's commitments, which should be noticeable at a glance while you're on the run.
    
    So for each element you encounter in the calendar ask yourself, does this element **need** to be done on this hard date? If the answer is no, then the calendar is not the correct place for the element to be.
    
    Using dates to order your tasks it's a waste of time, because there will always be a thousand of reasons why you can't do all the things you allocate to that day. As these not done issues start piling up, you'll start to get stressed with a lot of things that you were not able to do on the dates you deceived yourself you were supposed to do at and then you need to spend time defining a new date. Use next actions in your `todo` instead.

* New: [Priority management.](gtd.md#priority-management)

    You shouldn’t bother to create some external structuring of the priorities on your lists that you’ll then have to rearrange or rewrite as things change. Attempting to impose such scaffolding has been a big source of frustration in many people’s organizing. You’ll be prioritizing more intuitively as you see the whole list against quite a number of shifting variables. The list is just a way for you to keep track of the total inventory of active things to which you have made a commitment, and to have that inventory available for review.
    
    Therefore I'm going to try not to use orgmode's priorities for the tasks.

* New: [Soft recurrent tasks.](gtd.md#soft-recurrent-tasks)

    There are some tasks that have a soft recurrence meaning that once you do them you don't want them to show up in your list of actions until a specific time has passed. You could use a recurrent `DEADLINE` or `SCHEDULED` but as we've seen earlier that will clutter your calendar pretty soon. Try following the next workflow with these tasks:
    
    - Add the `:soft_recurrence:` tag to keep them tracked.
    - Add them to the tickler file with a recurrent appointment date `<2023-03-13 Mon ++1w>` and the `:tickler:` tag so that it doesn't show up in the agenda view even if you move it to another file.
    - When the appointed day comes you'll review the tickler elements as part of your day's routine. If you think it's time to do it, refile it to the `todo.org` file, if not, adjust the recurrence period and set the next date. Even though this workflow is reproducing the "kick the can forward" that we want to avoid, the idea is that once you get the period right you'll never have to do it again. If you see that after some iterations the period keeps on changing, maybe this workflow is not working for that kind of task and you may need to think of a better system `¯\(°_o)/¯`.
    - Once you complete the item, the new one will be spawned, once it has refile it to the tickler file again.
    
    We use appointments instead of `DEADLINE` or `SCHEDULED` so that they don't clutter the tickler view if you don't do them on the appointment date.
    
    Another option is not to archive the DONE tasks and in the weekly reset them to TODO the ones that you want to do the next week.

### [OpenProject](openproject.md)

* Correction: Suggest not to use openproject.

    I've decided to use [orgmode](orgmode.md) instead.

# Coding

## Languages

### [Click](click.md)

* New: [File system isolation.](click.md#file-system-isolation)

    You may need to isolate the environment variables if your application read the configuration from them. To do that override the `runner` fixture:
    
    ```python
    @pytest.fixture(name="runner")
    def fixture_runner() -> CliRunner:
        """Configure the Click cli test runner."""
        return CliRunner(
            env={
                'PASSWORD_STORE_DIR': '',
                'GNUPGHOME': '',
                'PASSWORD_AUTH_DIR': '',
            },
            mix_stderr=False
        )
    ```
    
    If you define the fixture in `conftest.py` you may need to use another name than `runner` otherwise it may be skipped, for example `cli_runner`.

### [SQLite](sqlite.md)

* New: [Import a table from another database.](sqlite.md#import-a-table-from-another-database)

    If you have an SQLite databases named `database1` with a table `t1` and `database2` with a table `t2` and want to import table `t2` from `database2` into `database1`. You need to open `database1` with `litecli`:
    
    ```bash
    litecli database1
    ```
    
    Attach the other database with the command:
    
    ```sqlite
    ATTACH 'database2file' AS db2;
    ```
    
    Then create the table `t2`, and copy the data over with:
    
    ```sqlite
    INSERT INTO t2 SELECT * FROM db2.t2;
    ```
    

### [Python Snippets](python_snippets.md)

* New: [Substract two paths.](python_snippets.md#substract-two-paths)

    It can also framed to how to get the relative path between two absolute paths:
    
    ```python
    >>> from pathlib import Path
    >>> p = Path('/home/lyz/')
    >>> h = Path('/home/')
    >>> p.relative_to(h)
    PosixPath('lyz')
    ```

# DevOps

## Infrastructure Solutions

### [AWS](aws.md)

* New: [Stop an EC2 instance.](aws.md#stop-an-ec2-instance)

    ```bash
    aws ec2 stop-instances --instance-ids i-xxxxxxxx
    ```

### [Kubectl Commands](kubectl_commands.md)

* New: [Show the remaining space of a persistent volume claim.](kubectl_commands.md#show-the-remaining-space-of-a-persistent-volume-claim)

    Either look it in Prometheus or run in the pod that has the PVC mounted:
    
    ```bash
    kubectl -n <namespace> exec <pod-name> -- df -ah
    ```
    
    You may need to use `kubectl get pod <pod-name> -o yaml` to know what volume is mounted where.

## Continuous Integration

### [Mypy](mypy.md)

* New: [Module "typing" has no attribute "Annotated".](mypy.md#module-"typing"-has-no-attribute-"annotated")

    This one happens only because `annotated` is not available in python < 3.9.
    
    ```
    try:
        # mypy is complaining that it can't import it, but it's solved below
        from typing import Annotated # type: ignore
    except ImportError:
        from typing_extensions import Annotated
    ```

### [ArgoCD](argocd.md)

* New: Introduce ArgoCD.

    [Argo CD](https://argo-cd.readthedocs.io/en/stable/) is a declarative, GitOps continuous delivery tool for Kubernetes.
    
    Argo CD follows the GitOps pattern of using Git repositories as the source of truth for defining the desired application state. Kubernetes manifests can be specified in several ways:
    
    - kustomize applications
    - helm charts
    - jsonnet files
    - Plain directory of YAML/json manifests
    - Any custom config management tool configured as a config management plugin, for example with [helmfile](#using-helmfile)
    
    Argo CD automates the deployment of the desired application states in the specified target environments. Application deployments can track updates to branches, tags, or pinned to a specific version of manifests at a Git commit. See tracking strategies for additional details about the different [tracking strategies available](https://argo-cd.readthedocs.io/en/stable/user-guide/tracking_strategies/).

# Operating Systems

## Linux

### [Linux Snippets](linux_snippets.md)

* New: [Force umount nfs mounted directory.](linux_snippets.md#force-umount-nfs-mounted-directory)

    ```bash
    umount -l path/to/mounted/dir
    ```

* New: [Configure fstab to mount nfs.](linux_snippets.md#configure-fstab-to-mount-nfs)

    NFS stands for ‘Network File System’. This mechanism allows Unix machines to share files and directories over the network. Using this feature, a Linux machine can mount a remote directory (residing in a NFS server machine) just like a local directory and can access files from it.
    
    An NFS share can be mounted on a machine by adding a line to the `/etc/fstab` file.
    
    The default syntax for `fstab` entry of NFS mounts is as follows.
    
    ```
    Server:/path/to/export /local_mountpoint nfs <options> 0 0
    ```
    
    Where:
    
    * `Server`: The hostname or IP address of the NFS server where the exported directory resides.
    * `/path/to/export`: The shared directory (exported folder) path.
    * `/local_mountpoint`: Existing directory in the host where you want to mount the NFS share.
    
    You can specify a number of options that you want to set on the NFS mount:
    
    * `soft/hard`: When the mount option `hard` is set, if the NFS server crashes or becomes unresponsive, the NFS requests will be retried indefinitely. You can set the mount option `intr`, so that the process can be interrupted. When the NFS server comes back online, the process can be continued from where it was while the server became unresponsive.
    
      When the option `soft` is set, the process will be reported an error when the NFS server is unresponsive after waiting for a period of time (defined by the `timeo` option). In certain cases `soft` option can cause data corruption and loss of data. So, it is recommended to use `hard` and `intr` options.
    
    * `noexec`: Prevents execution of binaries on mounted file systems. This is useful if the system is mounting a non-Linux file system via NFS containing incompatible binaries.
    * `nosuid`: Disables set-user-identifier or set-group-identifier bits. This prevents remote users from gaining higher privileges by running a setuid program.
    * `tcp`: Specifies the NFS mount to use the TCP protocol.
    * `udp`: Specifies the NFS mount to use the UDP protocol.
    * `nofail`: Prevent issues when rebooting the host. The downside is that if you have services that depend on the volume to be mounted they won't behave as expected.

* New: [Fix limit on the number of inotify watches.](linux_snippets.md#fix-limit-on-the-number-of-inotify-watches)

    Programs that sync files such as dropbox, git etc use inotify to notice changes to the file system. The limit can be see by -
    
    ```bash
    cat /proc/sys/fs/inotify/max_user_watches
    ```
    
    For me, it shows `65536`. When this limit is not enough to monitor all files inside a directory it throws this error.
    
    If you want to increase the amount of inotify watchers, run the following in a terminal:
    
    ```bash
    echo fs.inotify.max_user_watches=100000 | sudo tee -a /etc/sysctl.conf && sudo sysctl -p
    ```
    
    Where `100000` is the desired number of inotify watches.

* New: [Get class of a window.](linux_snippets.md#get-class-of-a-window)

    Use `xprop` and click the window.
    
    Get the current brightness level with `cat /sys/class/backlight/intel_backlight/brightness`. Imagine it's `1550`, then if you want to lower the brightness use:
    
    ```bash
    sudo echo 500 > /sys/class/backlight/intel_backlight/brightness
    ```

* New: [SSH tunnel.](linux_snippets.md#ssh-tunnel)

    ```bash
    ssh -D 9090 -N -f user@host
    ```

* New: [Fix the SSH client kex_exchange_identification: read: Connection reset by peer error.](linux_snippets.md#fix-the-ssh-client-kex_exchange_identification:-read:-connection-reset-by-peer-error)

    Restart the `ssh` service.

### [aleph](aleph.md)

* New: Add application operations.

    - [How to upgrade it](aleph.md#upgrade-aleph)
    - [Create Aleph admins](aleph.md#create-aleph-admins)
    - [Remove a group](aleph.md#remove-a-group)

### [Anki](anki.md)

* New: [How long to do study sessions.](anki.md#how-long-to-do-study-sessions)

    I have two study modes:
    
    * When I'm up to date with my cards, I study them until I finish, but usually less than 15 minutes.
    * If I have been lazy and haven't checked them in a while (like now) I assume I'm not going to see them all and define a limited amount of time to review them, say 10 to 20 minutes depending on the time/energy I have at the moment.
    
    The relief thought you can have is that as long as you keep a steady pace of 10/20 mins each day, inevitably you'll eventually finish your pending cards as you're more effective reviewing cards than entering new ones

* New: [What to do with "hard" cards.](anki.md#what-to-do-with-"hard"-cards)

    If you're afraid to be stuck in a loop of reviewing "hard" cards, don't be. In reality after you've seen that "hard" card three times in a row you won't mark it as hard again, because you will remember. If you don't maybe there are two reasons:
    
    * The card has too much information that should be subdivided in smaller cards.
    * You're not doing a good process of memorizing the contents once they show up.

### [i3wm](i3wm.md)

* New: [Move the focus to a container.](i3wm.md#move-the-focus-to-a-container)

    Get the container identifier with `xprop` and then:
    
    ```bash
    i3-msg '[title="khime"]' focus
    i3-msg '[class="Firefox"]' focus
    ```

* New: [Interact with Python.](i3wm.md#interact-with-python)

    Install the `i3ipc` library:
    
    ```bash
    pip install i3ipc
    ```
    
    Create the connection object:
    
    ```python
    from i3ipc import Connection, Event
    
    i3 = Connection()
    ```
    
    Interact with i3:
    
    ```python
    
    focused = i3.get_tree().find_focused()
    print('Focused window %s is on workspace %s' %
          (focused.name, focused.workspace().name))
    
    outputs = i3.get_outputs()
    
    print('Active outputs:')
    
    for output in filter(lambda o: o.active, outputs):
        print(output.name)
    
    i3.command('focus left')
    
    for container in i3.get_tree().find_fullscreen():
        container.command('fullscreen')
    
    root = i3.get_tree()
    print(root.name)
    for con in root:
        print(con.name)
    
    def on_workspace_focus(self, e):
        # The first parameter is the connection to the ipc and the second is an object
        # with the data of the event sent from i3.
        if e.current:
            print('Windows on this workspace:')
            for w in e.current.leaves():
                print(w.name)
    
    def on_window_focus(i3, e):
        focused = i3.get_tree().find_focused()
        ws_name = "%s:%s" % (focused.workspace().num, focused.window_class)
        i3.command('rename workspace to "%s"' % ws_name)
    
    i3.on(Event.WORKSPACE_FOCUS, on_workspace_focus)
    i3.on(Event.WINDOW_FOCUS, on_window_focus)
    
    i3.main()
    ```

### [Jellyfin](jellyfin.md)

* New: [Fix Corrupt: SQLitePCL.pretty.SQLiteException: database disk image is malformed.](jellyfin.md#corrupt:-sqlitepcl.pretty.sqliteexception:-database-disk-image-is-malformed)

    If your server log file shows SQLite errors like the following example your jellyfin.db file needs attention.
    
    ```
    'SQLitePCL.pretty.SQLiteException'
    ```
    
    Typical causes of this are sudden and abrupt terminations of the Emby server process, such as a power loss, operating system crash, force killing the server process, etc.
    
    To solve it there are many steps:
    
    * [Remove Database Locks](jellyfin.md#remove-database-locks)
    * [Check Database Integrity and Recover Database](jellyfin.md#check-database-integrity-and-recover-database)
    * [Reset Library Database & Load Fresh](jellyfin.md#reset-library-database-&-load-fresh)

* New: [Restore watched history.](jellyfin.md#restore-watched-history)

    Jellyfin stores the watched information in one of the `.db` files, there are two ways to restore it:
    
    * Using scripts that interact with the API like [`jelly-jar`](https://github.com/mueslimak3r/jelly-jar) or [`jellyfin-backup-watched`](https://github.com/jab416171/jellyfin-backup-watched)
    * Running sqlite queries on the database itself.
    
    The user data is stored in the table `UserDatas` table in the `library.db` database file. The media data is stored in the `TypedBaseItems` table of the same database.
    
    Comparing the contents of the tables of the broken database (lost watched content) and a backup database, I've seen that the media content is the same after a full library rescan, so the issue was fixed after injecting the missing user data from the backup to the working database through the [importing a table from another database](sqlite.md#import-a-table-from-another-database) sqlite operation.

* New: [Fix ReadOnly: SQLitePCL.pretty.SQLiteException: attempt to write a readonly database.](jellyfin.md#readonly:-sqlitepcl.pretty.sqliteexception:-attempt-to-write-a-readonly-database)

    Some of the database files of Jellyfin is not writable by the jellyfin user, check if you changed the ownership of the files, for example in the process of restoring a database file from backup.

## Android

### [Orgzly](orgzly.md)

* New: Introduce Orgzly.

    [Orgzly](https://orgzly.com/) is an android application to interact with [orgmode](orgmode.md) files.
    

# Other

* Correction: Update introduction.

    The method was described by David Allen in a book with the same name. It's clear that the book is the corner stone of David's business. He is selling his method on every word, some times to the point of tiresome. It's also repeats the same ideas on different parts of the book, I guess that's good in terms of sticking an idea in the people's mind, but if you're already convinced and are trying to sum up the book it's like, hey, I have 90% of the valuable contents of this chapter already in my summary. It's obvious too the context of the writer, that the book was written a while ago and who does it write to. It talks quite often about assistants, bosses of high firm companies he's helped, preferring low-tech physical solutions over digital ones, a lot of references about parenting... If you're able to ignore all the above, it's actually a very good book. The guy has been polishing the method for more than 30 years, and has pretty nice ideas that can change how you manage your life.
    
    My idea of this summary is to try to extract the useful ideas removing all those old-fashioned capitalist values from it.

* New: Guides on processing your inbox.

    Remember to follow the next rules while processing the items:
    
    - Process the top item first: that way you treat each element equally, so the "least" important ones are not left dangling forever in your inbox thus thwarting it's purpose.
    - Process one item at a time.
    - Never put anything back into “in.”
    
    For each element you need to ask yourself: "What's the next action?".

* New: How to clarify your inbox items.

    If you can do something about the element, you need to think which is the next physical, visible activity that would be required to move the situation towards closure. It's tricky, something like "set meeting" won't do because it's not descriptive of physical behaviour. There is still stuff to decide how, when, with whom, if you don't do it now you won't empty your head and the uncertainty will create a psychological gap that will make you procrastinate, so define the next action now. "Decide what to do about X" doesn't work either, you may need to gather more information on the topic, but deciding doesn't take time.
    
    Once you have the next action, if it can be done in two minutes or less, do it when you first pick the item up. Even if it is not a high-priority one, do it now if you’re ever going to do it at all. The rationale for the two-minute rule is that it’s more or less the point where it starts taking longer to store and track an item than to deal with it the first time it’s in your hands. Two minutes is just a guideline. If you have a long open window of time in which to process your in-tray, you can extend the cutoff for each item to five or ten minutes. If you’ve got to get to the bottom of all your input rapidly, then you may want to shorten the time to one minute, or even thirty seconds, so you can get through everything a little faster.
    
    There’s nothing you really need to track about your two-minute actions. Just do them. If, however, you take an action and don’t finish the project with that one action, you’ll need to clarify what’s next on it, and manage that according to the same criteria.
    
    If the next action is going to take longer than two minutes, ask yourself, “Am I the best person to be doing it?” If not, hand it off to the appropriate person, in order of priority:
    
    * Send an e-mail.
    * Write a note or an over-note on paper and route it to that person.
    * Send it a instant message.
    * Add it as an agenda item on a list for your next real-time conversation with that person.
    * Talk with her directly, either face-to-face or by phone.
    
    When you hand it off to someone else, and if you care at all whether something happens as a result, you’ll need to track it. Depending on how active you need to be it can go to your Waiting list or to your tickler.

* Correction: Deprecate pydo.

    I'm happy with orgmode so far, so I'm not going to continue it's
    development
